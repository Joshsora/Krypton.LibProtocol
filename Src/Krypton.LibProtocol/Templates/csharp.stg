init(root) ::= <<
<([root.TemplateName, "_template"])(root)>
>>

target_members(container) ::= <<
<container.Members: {m | <([m.TemplateName, "_template"])(m)>}; separator="\n">
>>

/**
    LIBRARY DECLARATION
*/

library_template(library) ::= <<
namespace <library.name>
{
    <target_members(library)>
}
>>

// groups
group_template(gobj) ::= <<
<gobj.Name>
>>

/**
    PROTOCOL DECLARATION
*/
protocol_template(protocol) ::= <<
public class <protocol.name>
{
    <target_members(protocol)>
}
>>

// messages
message_template(message) ::= <<
>>

/**
    PACKET DECLARATION
*/
packet_template(packet) ::= <<
public class <packet.Name> <packet_parent_builder(packet)>
{
}
>>

// Parent builder
packet_parent_builder(packet) ::= <<
<packet.Members: {m | <m.Name>}; separator=",">
>>

/**
    TYPE DECLARATION
*/

typedecl_template(typedecl) ::= <<
public class <typedecl.name> : <as_krypton_type(typedecl.name)>
{
    <typedecl_body(typedecl)>
}
>>

generic_typedecl_template(typedecl) ::= <<
public class <generic_decl_name(typedecl)> : <as_krypton_type(generic_decl_name(typedecl))>
    <typedecl.Generics:generic_constraint(); separator="\n">
{
    <typedecl_body(typedecl)>
}
>>

generic_decl_name(typedecl) ::= <<
<typedecl.name>\<<typedecl.Generics:{g | <g.name>}; separator="\n">\>
>>

generic_constraint(generic) ::= <<
where <generic.name>: <as_krypton_type(generic.name)>, new()
>>

typedecl_body(typedecl) ::= <<
<typedecl.Statements: {s | <([s.TemplateName, "_as_member"])(s)>}; separator="\n">

public override void Consume(Krypton.LibProtocol.BufferReader br)
{
    <typedecl.Statements: {s | <([s.TemplateName, "_ref"])(s)>.Consume(br);}; separator="\n">
}

public override void Write(Krypton.LibProtocol.BufferWriter bw)
{
    <typedecl.Statements: {s | <([s.TemplateName, "_ref"])(s)>.Write(bw);}; separator="\n">
}

public override void Build(Krypton.LibProtocol.BufferReader br)
{
    <typedecl.Statements: {s | <([s.TemplateName, "_builder"])(s)>}; separator="\n">
}
>>

/**
    STATEMENTS
*/

type_statement_builder(statement) ::= <<
<s.name> = <if(statement.Type.namespace)><formal_typeref(statement.Type)><else><as_krypton_type(formal_typeref(statement.Type))><endif>.Create();
<s.name>.Build(br);
>>

if_statement_builder(statement) ::= <<
<statement.Statements: {s | <([s.TemplateName, "_builder"])(s)>}; separator="\n">
>>

type_statement_ref(statement) ::= <<
<statement.name>
>>

if_statement_ref(statement) ::= <<
<statement.Statements: {s | <([s.TemplateName, "_ref"])(s)>}; separator="\n">
>>

type_statement_as_member(statement) ::= <<
public <formal_typeref(statement.Type)> <statement.name> { get; set; }
>>

if_statement_as_member(statement) ::= <<
<statement.Statements: {s | <([s.TemplateName, "_as_member"])(s)>}; separator="\n">
>>

/**
    TYPE REFERENCING
*/

formal_typeref(typeref) ::= <<
<if(typeref.namespace)><typeref.namespace>.<endif><(["resolve_", typeref.Type.TemplateName])(typeref.Type)>
>>

resolve_generic_type(type) ::= <<
<resolve_concrete_type(type)>\<<type.Generics:formal_typeref()>\>
>>

resolve_concrete_type(type) ::= <<
<if(builtin_type.(type.Name))><builtin_type.(type.Name)><else><type.name><endif>
>>

resolve_generic_attribute(generic) ::= <<
<generic.name>
>>

as_krypton_type(name) ::= <<
Krypton.LibProtocol.Type.KryptonType\<<name>\>
>>

// Builtin types to their perspective class names
builtin_type ::= [
    "byte": "ByteType",
    "bool": "BoolType",
    "int8": "Int8Type",
    "uint8": "UInt8Type",
    "int16": "Int16Type",
    "uint16": "UInt16Type",
    "int32": "Int32Type",
    "uint32": "UInt32Type",
    "int64": "Int64Type",
    "uint64": "UInt64Type",
    "string": "StringType",
    "cstring": "CStringType",
    "buffer": "BufferType",
    "array": "ArrayType"
]
